---
title: 前端项目依赖管理
date: 2024-09-02
tags: [前端]
---

在项目开发中，我们经常会遇到依赖管理的问题，
比如依赖冲突，或者某个依赖项升级后项目崩溃等等。
要解决这些问题，我们首先要理解版本依赖背后的机制，才能更好的管理依赖。

### 一、版本是怎么描述的？

前端依赖遵循语义化版本（SemVer）规范：主版本号.次版本号.修订号（MAJOR.MINOR.PATCH），例如 3.2.1：

MAJOR (主版本)：破坏性变更（不向下兼容，如移除 API、架构重构）。

MINOR (次版本)：新增功能（向下兼容，如添加新 API）。

PATCH (修订号)：问题修复（向下兼容，如修复 bug、优化性能）。

| **符号**       | **含义**                     | **示例**      | **允许安装的版本范围**               |
|----------------|-----------------------------|---------------|--------------------------------------|
| **`^`（推荐）** | 允许次版本和修订号更新       | `^3.2.1`      | `>=3.2.1 且 <4.0.0`                  |
| **`~`**        | 仅允许修订号更新             | `~3.2.1`      | `>=3.2.1 且 <3.3.0`                  |
| **无符号**      | 锁定精确版本                 | `3.2.1`       | **仅 3.2.1**                         |
| **`>` 或 `<`** | 指定版本范围                 | `>2.0.0 <3.0.0` | `2.0.1 到 2.9.9`                  |


### 二、外部依赖是怎么更新的

接下来讨论三种常见的项目依赖情况。

假设现在依赖安装逻辑如下：
```text
package-m1 > dayjs@1.11.5
package-m2 > dayjs@1.11.5
package-m3 > dayjs@1.11.0
package-m3@2.0.0 > dayjs@1.11.5
```

#### 情况一：项目依赖package-m1 + package-m2
依赖树解析结果：

```text
node_modules/
├── package-m1/     # 直接依赖
├── package-m2/     # 直接依赖
└── dayjs@1.11.5    # 被提升的公共依赖

```
结论：两个包都要求 dayjs@1.11.5，相同版本被提升到顶层，项目中使用单一 dayjs 实例。

#### 情况二：项目依赖 package-m1 + package-m3
依赖树解析结果：

```text
node_modules/
├── package-m1/
│   └── (依赖 dayjs@1.11.5)
├── package-m3/
│   ├── node_modules/
│   │   └── dayjs@1.11.0  # 私有安装
│   └── (依赖 dayjs@1.11.0)
└── dayjs@1.11.5          # 顶层安装

```
结论：

package-m1 使用顶层 dayjs@1.11.5

package-m3 使用自己的私有 dayjs@1.11.0

项目中有两个 dayjs 实例（内存中独立存在）

#### 情况三：package.json 与 lock 文件不一致

```json// package.json
"dependencies": {
  "package-m1": "^1.0.0",
  "package-m3": "^1.0.0"   // 要求 v1 版本
}

// package-lock.json 中却记录了：
"package-m3": {
  "version": "2.0.0",      // lock 中锁定 v2
  "requires": {
    "dayjs": "1.11.5"
  }
}
```

```bash
# npm 的行为（v7+）
npm install → 自动更新 lock 文件匹配 package.json
```
最终安装结果：

```text
node_modules/
├── package-m1/ → dayjs@1.11.5 (顶层)
├── package-m3@1.x.x/ # 安装满足 ^1.0.0 的最新 v1 版本
│   └── node_modules/
│       └── dayjs@1.11.0
└── dayjs@1.11.5
```
结论：

lock 文件会被更新 以匹配 package.json 的约束

最终安装的是 package-m3 的 v1 版本（依赖 dayjs@1.11.0）

dayjs 仍然保持两个实例（1.11.5 在顶层，1.11.0 在嵌套层）

### 三、总结

实际开发中，经常会因为各种依赖不一致而产生奇怪的问题，或者在某些场景下，我们不希望依赖被更新，建议在开发中使用 package-lock.json。

锁定依赖版本意味着在我们不手动执行更新的情况下，每次安装依赖都会安装固定版本。保证整个团队使用版本号一致的依赖。

每次安装固定版本，无需计算依赖版本范围，大部分场景下能大大加速依赖安装时间。


